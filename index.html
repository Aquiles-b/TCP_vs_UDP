<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>TCP vs UDP</title>
</head>
<body>
	<header>
		<h1>TCP vs UDP</h1>
	</header>
	<main>
		<section>
			<h2>Comunicação</h2>
			<ol>
				<li>Cliente inicia conexão com servidor</li>
				<li>Cliente envia o nome do arquivo que deseja baixar (max 256 bytes)</li>
				<li>Servidor abre o arquivo</li>
				<li>Servidor envia mensagem com tamanho do arquivo, tamanho do buffer de transmissão e tamanho de janela no caso do UDP.</li>
				<li>Cliente recebe dados de transmissão, aloca buffer e se prepara para receber dados</li>
				<li>Servidor envia dados do arquivo para o cliente</li>
				<li>Servidor encerra conexão</li>
				<li>Cliente fecha arquivo</li>
			</ol>
			<p>O servidor TCP pode funcionar de tanto de forma iterativa, quanto de forma paralela com a criação de uma thread para lidar com cada cliente novo. Já o servidor UDP funciona somente de forma iterativa, mas foi considerado fazer de forma paralela por meio da criação de sockets utilizando outras portas e um socket que imita um socket em modo de escuta TCP, que iria redirecionar os clientes para outra porta e possibilitando o envio de arquivos de forma paralela por meio de outras threads, entretanto por conta da complexidade, essa ideia foi deixada de lado.</p>
		</section>

		<section>
			<h2>Arquivos</h2>
			<ul>
				<li>Servidor guarda os arquivos no diretório <tt>files</tt>, utilizando ele como raíz para procura de arquivos.</li>
				<li>Cliente salva os arquivos baixados no diretório <tt>downloads</tt>.</li>
			</ul>
		</section>

		<section>
			<h2>Utilização</h2>
			<p>Para compilar o código, basta rodar o comando <tt>make</tt>, desde que o Makefile e g++ estejam instalados.</p>
			<p>Para rodar o servidor:</p>
			<tt class="bash">./server &lt;ipv4_addr&gt; &lt;port&gt; &lt;protocol&gt; &lt;buffer_size&gt; &lt;win_size_udp | mode_tcp(iter|par)&gt;</tt>
			<p>Sendo que o endereço IPv4 é o endereço que se deseja rodar o servidor, geralmente 0.0.0.0 ou 127.0.0.1. Também é necessário a porta que o servidor deve usar, o protocolo de transporte ("tcp" ou "udp"), tamanho do buffer utilizado para as transmissões e o último argumento varia de acordo com o protocolo de transporte. No caso do UDP, é o tamanho da janela utilizada na janela deslizante (em quantidade de segmentos que possuem tamanho <tt>&lt;buffer_size&gt;</tt>), enquanto no TCP é o modo do servidor ("iter" para iterativo e "par" para paralelo)</p>
			<p>Para rodar o cliente:</p>
			<tt class="bash">./client &lt;server_ipv4_addr&gt; &lt;server_port&gt; &lt;protocol&gt; &lt;fname&gt; &lt;fout&gt;</tt>
			<p>Onde é necessário o endereço IPv4 do servidor, a porta do servidor, o protocolo ("tcp" ou "udp"), o nome do arquivo que será baixado e o nome do arquivo que será salvo.</p>
		</section>

		<section>
			<h2>Implementação</h2>
			<p>A implementação da comunicação sobre TCP não há nada de especial, o servidor começa a transmitir a sequência de bytes do arquivo para o cliente, e o próprio protocolo cuida do controle de fluxo, sequencialização, etc. Entretanto, no UDP foi implementado o controle de fluxo por meio de janelas deslizantes, sequencialização e confirmação de mensagens.</p>
			<h3>Diagrama de Classes do Projeto</h3>
			<img src="files/class-diag.png" alt="Diagrama de classes UML" style="width: 100%;">
			<h3>Código-fonte</h3>
			<pre>
project/
├── include
│   ├── <a target="_blank" href="project/include/basic_client.hpp">basic_client.hpp</a>
│   ├── <a target="_blank" href="project/include/basic_server.hpp">basic_server.hpp</a>
│   ├── <a target="_blank" href="project/include/protocol.h">protocol.h</a>
│   ├── <a target="_blank" href="project/include/tcp_client.hpp">tcp_client.hpp</a>
│   ├── <a target="_blank" href="project/include/tcp_server.hpp">tcp_server.hpp</a>
│   ├── <a target="_blank" href="project/include/udp_client.hpp">udp_client.hpp</a>
│   └── <a target="_blank" href="project/include/udp_server.hpp">udp_server.hpp</a>
└── src
		├── <a target="_blank" href="project/src/basic_client.cpp">basic_client.cpp</a>
		├── <a target="_blank" href="project/src/basic_server.cpp">basic_server.cpp</a>
		├── <a target="_blank" href="project/src/client.cpp">client.cpp</a>
		├── <a target="_blank" href="project/src/server.cpp">server.cpp</a>
		├── <a target="_blank" href="project/src/tcp_client.cpp">tcp_client.cpp</a>
		├── <a target="_blank" href="project/src/tcp_server.cpp">tcp_server.cpp</a>
		├── <a target="_blank" href="project/src/udp_client.cpp">udp_client.cpp</a>
		└── <a target="_blank" href="project/src/udp_server.cpp">udp_server.cpp</a>
			</pre>
			<p>Os arquivos <tt>client.cpp</tt> e <tt>server.cpp</tt> contém as implementações da interface de linha de comando do cliente e servidor, respectivamente. O arquivo <tt>protocol.h</tt> contém definições utilizadas tanto pelo cliente quanto pelo servidor, servindo como um arquivo comum apenas para definição de um enum.</p>
			<p>O código também está disponível no <a target="_blank" href="https://github.com/Aquiles-b/TCP_vs_UDP">GitHub</a></p>
		</section>
		<section>
			<h2>Testes</h2>
			<p>Os mesmos testes para servidor iterativo serão feitos para servidor paralelo.</p>
			<p>Dois tipos de teste:</p>
			<ul>
				<li>Rede local </li>
				<li>Passando pela internet (Usando LAN virtual/radmin)</li>
			</ul>
			<p>Cada teste é feito com base no número de clientes:</p>
			<ul>
				<li>O número de clientes começa em 1 e vai dobrando até 64.</li>
				<li>Cada cliente faz uma transferência de arquivos de 1MB, 10MB, 100MB e 1GB</li>
				<li>Os dados de cada teste são salvos em um arquivo CSV</li>
			</ul>
			<p>Para cada teste, será analisado as métricas:</p>
			<ul>
				<li>Perda de pacotes</li>
				<li>Tempo de download</li>
				<li>sha256sum do arquivo baixado</li>
			</ul>
			
					<h3>Estrutura de diretórios</h3>
			<p>Cada teste vai gerar logs salvos no diretório <tt>logs/</tt> com a seguinte estrutura:</p>
			<pre>
logs
├── client
│   ├── rede_externa
│   │   ├── TCP
│   │   └── UDP
│   └── rede_local
│       ├── TCP
│       │   ├── iter_1.csv
│       │   ├── iter_2.csv
│       │   ├── par_1.csv
│       │   └── par_2.csv
│       └── UDP
│           ├── iter_1.csv
│           └── iter_2.csv
└── server
		├── rede_externa
		│   ├── TCP
		│   └── UDP
		└── rede_local
				├── TCP
				│   ├── iter_2_8192.txt
				│   └── par_4_4096.txt
				└── UDP
						├── iter_2_8192_8.txt
						└── par_2_4096_15.txt
			</pre>
			<h4>Logs server</h4>
			<p>
				Onde <tt>iter_2_8192.txt</tt> é o log do servidor TCP iterativo com tamanho de buffer igual a 8192 bytes atendendo 2 clientes. Enquanto
				<tt>parX_N.txt</tt> é o log do servidor TCP paralelo com tamanho de buffer N bytes atendendo X clientes.
			</p>
			<p>
				Para o UDP, é a mesma coisa com a adição do tamanho da janela no final do nome. Por exemplo,
				<tt>iter_X_N_M.txt</tt> é o servidor UDP iterativo com tamanho de buffer igual a N bytes e tamanho de janela M atendendo X clintes. Como não há implementação do servidor UDP "paralelo", não há logs em paralelo para o UDP.
			</p>
			<h4>Logs client</h4>
			<p>
				<tt>iter_X_N.csv</tt> é o log da conexão de X clientes com um servidor iterativo que possui um buffer de transmissão de N bytes. Enquanto
				<tt>par_X_N.csv</tt> é a conexão de X clientes com um servidor paralelo que possui um buffer de transmissão de N bytes.
				No caso do UDP, os <tt>csv</tt> também possuem o campo de janela, sendo nomeados da seguinte forma: <tt>iter_X_N_M.csv</tt> onde X é o número de clientes, N é o tamanho do buffer e M é o tamanho da janela do controle de fluxo.
			</p>
			<p>Cada arquivo <tt>csv</tt> terá a seguinte estrutura:</p>
			<table class="tab-log">
				<thead>
					<tr>
						<th>Num tentativas</th>
						<th>Perda de pacotes</th>
						<th>Tempo de download</th>
						<th>Sha256sum</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>N</td>
						<td>c1_x0</td>
						<td>c1_y0</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c1_x1</td>
						<td>c1_y1</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c1_x2</td>
						<td>c1_y2</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c1_x3</td>
						<td>c1_y3</td>
						<td>1</td>
					</tr>
					<tr>
						<td>-</td>
						<td>-</td>
						<td>Tempo de teste total</td>
						<td>-</td>
					</tr>
				</tbody>
			</table>
			<p>Onde cada linha é uma transmissão de arquivo para um cliente <tt>cn</tt>. A primeira coluna indica o número de tentativas necessárias para baixar o arquivo, útil somente no caso do UDP, por causa que o servidor iterativo fica recusando clientes enquanto está enviando um arquivo para o cliente. A segunda coluna mostra a perda de pacotes do cliente durante o download, mas assim como o número de tentativas, é útil somente para a análise do UDP. A terceira coluna é o tempo de download, quanto tempo o cliente levou para baixar o arquivo de teste. A última coluna é o resultado da comparação do checksum SHA-256 entre o arquivo original e o arquivo baixado.</p>
			<p>A última linha do <tt>csv</tt> apresenta um único valor que fica na terceira coluna, representando o tempo total de um teste/bateria de clientes, útil no caso do TCP paralelo, onde o tempo total não é necessariamente a soma do tempo de todos os clientes.</p>
			<p>Exemplo de arquivo <tt>csv</tt> gerado de um teste com 2 clientes:</p>
			<table class="tab-log">
				<thead>
					<tr>
						<th>Num tentativas</th>
						<th>Perda de pacotes</th>
						<th>Tempo de download</th>
						<th>Sha256sum</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>N</td>
						<td>c1_x0</td>
						<td>c1_y0</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c2_a0</td>
						<td>c2_b0</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c1_x1</td>
						<td>c1_y1</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c2_a1</td>
						<td>c2_b1</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c1_x2</td>
						<td>c1_y2</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c2_a2</td>
						<td>c2_b2</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c1_x3</td>
						<td>c1_y3</td>
						<td>1</td>
					</tr>
					<tr>
						<td>N</td>
						<td>c2_a3</td>
						<td>c2_b3</td>
						<td>1</td>
					<tr>
						<td>-</td>
						<td>-</td>
						<td>Tempo de teste total</td>
						<td>-</td>
					</tr>
				</tbody>
			</table>
			<h3>Condução dos Testes</h3>
			<p>Para a realização dos testes foi implementado um servidor HTTP simples que possibilita o cliente instanciar o servidor de testes remotamente, permitindo a automatização de todos os testes. A implementação desse servidor foi feita em liguagem Python e o código pode ser encontrado no diretório <tt>scripts</tt>.</p>
			<pre>
scripts/
├── <a href="scritps/estrutura.sh" target="_blank">estrutura.sh</a>
├── <a href="scritps/gen_files.py" target="_blank">gen_files.py</a>
├── <a href="scritps/run_test.py" target="_blank">run_test.py</a>
└── <a href="scritps/server_manager.py" target="_blank">server_manager.py</a>
			</pre>
			<p>O arquivo <tt>estrutura.sh</tt> é um script para gerar a estrutura de diretórios necessária para a realização dos testes. O <tt>gen_files.py</tt> gera arquivos aleatórios de 1MB, 10MB, 100MB e 1GB para utilização nos testes. O script <tt>run_test.py</tt> é o cliente HTTP que faz a instanciação de múltiplos clientes em paralelo para realizar os testes dos protocolos TCP e UDP. Por fim, o <tt>server_manager.py</tt> é o servidor HTTP que gerencia o servidor de teste, instanciando novos servidores em portas diferentes quando requisitado.</p>
			<p>Foram realizados testes simulando a execução de 1, 2, 4, e 8 clientes requirindo arquivos de 10MB para o servidor. Para o TCP, foram realizados testes variando o número de clientes, o tamanho do buffer de transmissão e o modo do servidor (iterativo ou paralelo). Para o UDP, o modo não variou porque ele possui somente o modo iterativo, entretanto o tamanho da janela do controle de fluxo foi variado. Foram utilizados arquivos de somente 10MB por causa da grande quantidade de testes que resultam em um tráfego de rede muito alto, fazendo os testes ficarem muito extensos.</p>
			<p>Após a tranferência de arquivos, o script calcula o hash SHA-256 do arquivo baixado e do arquivo original (o cliente precisa ter uma cópia do arquivo original antes de rodar os testes) e compara, colocando 1 no seu log csv caso o hash seja igual ao original e 0 caso contrário, permitindo o cálculo da taxa de sucesso de download e a necessidade de verificação de erros.</p>
		</section>
		<section>
			<h2>Resultados</h2>
			<!--TODO: Comentar os resultados-->
		</section>
	</main>

</body>
</html>
